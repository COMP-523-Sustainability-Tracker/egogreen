import { __decorate, __metadata } from "tslib";
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, Directive, ElementRef, EventEmitter, forwardRef, Host, HostListener, inject, Inject, InjectionToken, Input, IterableDiffers, Output, TemplateRef, ViewChild, ViewContainerRef } from '@angular/core';
import { LayoutBase, ObservableArray, profile } from '@nativescript/core';
import { extractSingleViewRecursive } from '../../element-registry/registry';
import { NativeScriptDebug } from '../../trace';
import { isListLikeIterable } from '../../utils/general';
import * as i0 from "@angular/core";
const NG_VIEW = '_ngViewRef';
export const TEMPLATED_ITEMS_COMPONENT = new InjectionToken('TemplatedItemsComponent');
export class ItemContext {
    constructor($implicit, item, index, even, odd) {
        this.$implicit = $implicit;
        this.item = item;
        this.index = index;
        this.even = even;
        this.odd = odd;
    }
}
export class NsTemplatedItem {
    constructor(template, location, onCreate) {
        this.template = template;
        this.location = location;
        this.onCreate = onCreate;
    }
    create(context) {
        const viewRef = this.location.createEmbeddedView(this.template, context ? this.setupItemContext(context) : new ItemContext());
        viewRef.detach(); // create detached, just beware this doesn't always work and the view might run the first CD anyway.
        const resultView = getItemViewRoot(viewRef);
        resultView[NG_VIEW] = viewRef;
        if (this.onCreate) {
            this.onCreate(resultView);
        }
        return resultView;
    }
    update(view, context) {
        const viewRef = this.getEmbeddedViewRef(view);
        this.setupItemContext(context, viewRef);
        viewRef?.detectChanges();
    }
    attach(view) {
        const viewRef = this.getEmbeddedViewRef(view);
        viewRef?.reattach();
        viewRef?.detectChanges();
    }
    detach(view) {
        const viewRef = this.getEmbeddedViewRef(view);
        viewRef?.detach();
    }
    dispose(view) {
        const viewRef = this.getEmbeddedViewRef(view);
        viewRef?.destroy();
    }
    getEmbeddedViewRef(view) {
        let viewRef = view[NG_VIEW];
        // Getting angular view from original element (in cases when ProxyViewContainer
        // is used NativeScript internally wraps it in a StackLayout)
        if (!viewRef && view instanceof LayoutBase && view.getChildrenCount() > 0) {
            viewRef = view.getChildAt(0)[NG_VIEW];
        }
        return viewRef;
    }
    isValid(view) {
        return !!this.getEmbeddedViewRef(view);
    }
    setupItemContext({ index, data }, oldView) {
        const context = oldView ? oldView.context : new ItemContext();
        context.$implicit = data;
        context.item = data;
        context.index = index;
        context.even = index % 2 === 0;
        context.odd = !context.even;
        return context;
    }
}
class ListViewComponent {
    get nativeElement() {
        return this.templatedItemsView;
    }
    get items() {
        return this._items;
    }
    set items(value) {
        this._items = value;
        let needDiffer = true;
        if (value instanceof ObservableArray) {
            needDiffer = false;
        }
        if (needDiffer && !this._differ && isListLikeIterable(value)) {
            this._differ = this._iterableDiffers.find(this._items).create((_index, item) => {
                return item;
            });
        }
        this.templatedItemsView.items = this._items;
    }
    // this elementRef is only here for backwards compatibility reasons
    constructor(_elementRef) {
        this._iterableDiffers = inject(IterableDiffers);
        this._changeDetectorRef = inject(ChangeDetectorRef);
        this._elementRef = inject(ElementRef);
        // I believe this only exists so this can be inherited and people can override it.
        this.templatedItemsView = this._elementRef.nativeElement;
        this._viewToTemplate = new WeakMap();
        this.setupItemView = new EventEmitter();
        if (_elementRef) {
            this.templatedItemsView = _elementRef.nativeElement;
        }
    }
    ngAfterContentInit() {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.listViewLog('TemplatedItemsView.ngAfterContentInit()');
        }
        this.setItemTemplates();
    }
    ngOnDestroy() {
        this.templatedItemsView = null;
        if (this._templateMap) {
            this._templateMap.clear();
        }
    }
    setItemTemplates() {
        // The itemTemplateQuery may be changed after list items are added that contain <template> inside,
        // so cache and use only the original template to avoid errors.
        this.fallbackItemTemplate = this.itemTemplateQuery;
        if (this.fallbackItemTemplate && !this._templateMap?.has('default')) {
            // apparently you can create a Core ListView without a template...
            // we also add a fallback default for when the user sets multiple templates but no templateSelector
            this.registerTemplate('default', this.fallbackItemTemplate);
        }
        if (this._templateMap) {
            // sometimes templates are registered before loader is ready, so we update here
            this._templateMap.forEach((t) => (t.location = this.loader));
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.listViewLog('Setting templates');
            }
            const templates = [];
            this._templateMap.forEach((value, key) => {
                templates.push({
                    createView: () => null,
                    key,
                });
            });
            this.templatedItemsView.itemTemplates = templates;
        }
    }
    registerTemplate(key, template) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.listViewLog(`registerTemplate for key: ${key}, ${this.loader}`);
        }
        if (!this._templateMap) {
            this._templateMap = new Map();
        }
        this._templateMap.set(key, new NsTemplatedItem(template, this.loader, (v) => this._viewToTemplate.set(v, key)));
    }
    onItemLoading(args) {
        if (!this._templateMap) {
            return;
        }
        const index = args.index;
        const lview = args.object;
        const items = lview.items;
        const currentItem = 'getItem' in items && typeof items.getItem === 'function' ? items.getItem(index) : items[index];
        let template;
        if (args.view) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.listViewLog(`onItemLoading: ${index} - Reusing existing view`);
            }
            let templateKey = this._viewToTemplate.get(args.view);
            if (!templateKey && args.view instanceof LayoutBase && args.view.getChildrenCount() > 0) {
                templateKey = this._viewToTemplate.get(args.view.getChildAt(0));
            }
            if (!templateKey) {
                // this template was not created by us
                if (NativeScriptDebug.isLogEnabled()) {
                    NativeScriptDebug.listViewError(`ViewReference not found for item ${index}. View recycling is not working`);
                }
                return;
            }
            template = this._templateMap.get(templateKey);
            template.update(args.view, { index, data: currentItem });
        }
        else {
            // this should never enter if it creates the view
            const templateKey = typeof lview.itemTemplateSelector === 'function' ? lview.itemTemplateSelector(currentItem, index, items) : 'default';
            template = this._templateMap.get(templateKey);
            if (!template) {
                if (NativeScriptDebug.isLogEnabled()) {
                    NativeScriptDebug.listViewError(`Template for key '${templateKey}' not found.`);
                }
                return;
            }
            args.view = template.create({ index, data: currentItem });
        }
        this.setupViewRef(template.getEmbeddedViewRef(args.view), currentItem, index, args.view);
        template.attach(args.view);
        this._changeDetectorRef.detectChanges();
    }
    setupViewRef(viewRef, data, index, nativeElement) {
        const context = viewRef.context;
        this.setupItemView.next({ view: viewRef, nativeElement, data: data, index: index, context: context });
    }
    ngDoCheck() {
        if (this._differ) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.listViewLog('ngDoCheck() - execute differ');
            }
            const changes = this._differ.diff(this._items);
            if (changes) {
                if (NativeScriptDebug.isLogEnabled()) {
                    NativeScriptDebug.listViewLog('ngDoCheck() - refresh');
                }
                this.templatedItemsView.refresh();
            }
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.1", ngImport: i0, type: ListViewComponent, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.0.1", type: ListViewComponent, selector: "ListView", inputs: { items: "items" }, outputs: { setupItemView: "setupItemView" }, host: { listeners: { "itemLoading": "onItemLoading($event)" } }, providers: [{ provide: TEMPLATED_ITEMS_COMPONENT, useExisting: forwardRef(() => ListViewComponent) }], queries: [{ propertyName: "itemTemplateQuery", first: true, predicate: TemplateRef, descendants: true, read: TemplateRef }], viewQueries: [{ propertyName: "loader", first: true, predicate: ["loader"], descendants: true, read: ViewContainerRef, static: true }], ngImport: i0, template: `<DetachedContainer>
    <ng-container #loader></ng-container>
  </DetachedContainer>`, isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
__decorate([
    profile,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], ListViewComponent.prototype, "onItemLoading", null);
export { ListViewComponent };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.1", ngImport: i0, type: ListViewComponent, decorators: [{
            type: Component,
            args: [{
                    // eslint-disable-next-line @angular-eslint/component-selector
                    selector: 'ListView',
                    template: `<DetachedContainer>
    <ng-container #loader></ng-container>
  </DetachedContainer>`,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [{ provide: TEMPLATED_ITEMS_COMPONENT, useExisting: forwardRef(() => ListViewComponent) }],
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { loader: [{
                type: ViewChild,
                args: ['loader', { read: ViewContainerRef, static: true }]
            }], setupItemView: [{
                type: Output
            }], itemTemplateQuery: [{
                type: ContentChild,
                args: [TemplateRef, { read: TemplateRef, static: false }]
            }], items: [{
                type: Input
            }], onItemLoading: [{
                type: HostListener,
                args: ['itemLoading', ['$event']]
            }] } });
export function getItemViewRoot(viewRef, rootLocator = extractSingleViewRecursive) {
    const rootView = rootLocator(viewRef.rootNodes, 0);
    return rootView;
}
// eslint-disable-next-line @angular-eslint/directive-selector
class TemplateKeyDirective {
    constructor(templateRef, comp) {
        this.templateRef = templateRef;
        this.comp = comp;
    }
    set nsTemplateKey(value) {
        if (this.comp && this.templateRef) {
            this.comp.registerTemplate(value, this.templateRef);
        }
    }
    set nsTemplateKeys(values) {
        // single template with multiple keys
        if (this.comp && this.templateRef && values) {
            values.forEach((value) => this.comp.registerTemplate(value, this.templateRef));
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.1", ngImport: i0, type: TemplateKeyDirective, deps: [{ token: i0.TemplateRef }, { token: TEMPLATED_ITEMS_COMPONENT, host: true }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.0.1", type: TemplateKeyDirective, selector: "[nsTemplateKey],[nsTemplateKeys]", inputs: { nsTemplateKey: "nsTemplateKey", nsTemplateKeys: "nsTemplateKeys" }, ngImport: i0 }); }
}
export { TemplateKeyDirective };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.1", ngImport: i0, type: TemplateKeyDirective, decorators: [{
            type: Directive,
            args: [{ selector: '[nsTemplateKey],[nsTemplateKeys]' }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef }, { type: undefined, decorators: [{
                    type: Host
                }, {
                    type: Inject,
                    args: [TEMPLATED_ITEMS_COMPONENT]
                }] }]; }, propDecorators: { nsTemplateKey: [{
                type: Input
            }], nsTemplateKeys: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGlzdC12aWV3LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL2FuZ3VsYXIvc3JjL2xpYi9jZGsvbGlzdC12aWV3L2xpc3Qtdmlldy5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBb0IsdUJBQXVCLEVBQUUsaUJBQWlCLEVBQUUsU0FBUyxFQUFFLFlBQVksRUFBRSxTQUFTLEVBQVcsVUFBVSxFQUFtQixZQUFZLEVBQUUsVUFBVSxFQUFFLElBQUksRUFBRSxZQUFZLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxjQUFjLEVBQUUsS0FBSyxFQUFrQixlQUFlLEVBQXFCLE1BQU0sRUFBRSxXQUFXLEVBQUUsU0FBUyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2xXLE9BQU8sRUFBZ0MsVUFBVSxFQUFZLGVBQWUsRUFBRSxPQUFPLEVBQVEsTUFBTSxvQkFBb0IsQ0FBQztBQUV4SCxPQUFPLEVBQUUsMEJBQTBCLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUM3RSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFFaEQsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0scUJBQXFCLENBQUM7O0FBRXpELE1BQU0sT0FBTyxHQUFHLFlBQVksQ0FBQztBQU03QixNQUFNLENBQUMsTUFBTSx5QkFBeUIsR0FBRyxJQUFJLGNBQWMsQ0FBcUIseUJBQXlCLENBQUMsQ0FBQztBQUUzRyxNQUFNLE9BQU8sV0FBVztJQUN0QixZQUFtQixTQUFhLEVBQVMsSUFBUSxFQUFTLEtBQWMsRUFBUyxJQUFjLEVBQVMsR0FBYTtRQUFsRyxjQUFTLEdBQVQsU0FBUyxDQUFJO1FBQVMsU0FBSSxHQUFKLElBQUksQ0FBSTtRQUFTLFVBQUssR0FBTCxLQUFLLENBQVM7UUFBUyxTQUFJLEdBQUosSUFBSSxDQUFVO1FBQVMsUUFBRyxHQUFI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LEVBQUU7WUFDM0MsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7U0FDaEY7SUFDSCxDQUFDOzhHQWZVLG9CQUFvQiw2Q0FDa0MseUJBQXlCO2tHQUQvRSxvQkFBb0I7O1NBQXBCLG9CQUFvQjsyRkFBcEIsb0JBQW9CO2tCQURoQyxTQUFTO21CQUFDLEVBQUUsUUFBUSxFQUFFLGtDQUFrQyxFQUFFOzswQkFFUCxJQUFJOzswQkFBSSxNQUFNOzJCQUFDLHlCQUF5Qjs0Q0FHdEYsYUFBYTtzQkFEaEIsS0FBSztnQkFPRixjQUFjO3NCQURqQixLQUFLIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWZ0ZXJDb250ZW50SW5pdCwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENoYW5nZURldGVjdG9yUmVmLCBDb21wb25lbnQsIENvbnRlbnRDaGlsZCwgRGlyZWN0aXZlLCBEb0NoZWNrLCBFbGVtZW50UmVmLCBFbWJlZGRlZFZpZXdSZWYsIEV2ZW50RW1pdHRlciwgZm9yd2FyZFJlZiwgSG9zdCwgSG9zdExpc3RlbmVyLCBpbmplY3QsIEluamVjdCwgSW5qZWN0aW9uVG9rZW4sIElucHV0LCBJdGVyYWJsZURpZmZlciwgSXRlcmFibGVEaWZmZXJzLCBOZ1pvbmUsIE9uRGVzdHJveSwgT3V0cHV0LCBUZW1wbGF0ZVJlZiwgVmlld0NoaWxkLCBWaWV3Q29udGFpbmVyUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJdGVtRXZlbnREYXRhLCBLZXllZFRlbXBsYXRlLCBMYXlvdXRCYXNlLCBMaXN0VmlldywgT2JzZXJ2YWJsZUFycmF5LCBwcm9maWxlLCBWaWV3IH0gZnJvbSAnQG5hdGl2ZXNjcmlwdC9jb3JlJztcblxuaW1wb3J0IHsgZXh0cmFjdFNpbmdsZVZpZXdSZWN1cnNpdmUgfSBmcm9tICcuLi8uLi9lbGVtZW50LXJlZ2lzdHJ5L3JlZ2lzdHJ5JztcbmltcG9ydCB7IE5hdGl2ZVNjcmlwdERlYnVnIH0gZnJvbSAnLi4vLi4vdHJhY2UnO1xuaW1wb3J0IHsgTmdWaWV3VGVtcGxhdGUgfSBmcm9tICcuLi8uLi92aWV3LXJlZnMnO1xuaW1wb3J0IHsgaXNMaXN0TGlrZUl0ZXJhYmxlIH0gZnJvbSAnLi4vLi4vdXRpbHMvZ2VuZXJhbCc7XG5cbmNvbnN0IE5HX1ZJRVcgPSAnX25nVmlld1JlZic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVtcGxhdGVkSXRlbXNIb3N0PFQgPSBhbnk+IHtcbiAgcmVnaXN0ZXJUZW1wbGF0ZShrZXk6IHN0cmluZywgdGVtcGxhdGU6IFRlbXBsYXRlUmVmPFQ+KTtcbn1cblxuZXhwb3J0IGNvbnN0IFRFTVBMQVRFRF9JVEVNU19DT01QT05FTlQgPSBuZXcgSW5qZWN0aW9uVG9rZW48VGVtcGxhdGVkSXRlbXNIb3N0PignVGVtcGxhdGVkSXRlbXNDb21wb25lbnQnKTtcblxuZXhwb3J0IGNsYXNzIEl0ZW1Db250ZXh0PFQ+IHtcbiAgY29uc3RydWN0b3IocHVibGljICRpbXBsaWNpdD86IFQsIHB1YmxpYyBpdGVtPzogVCwgcHVibGljIGluZGV4PzogbnVtYmVyLCBwdWJsaWMgZXZlbj86IGJvb2xlYW4sIHB1YmxpYyBvZGQ/OiBib29sZWFuKSB7fVxufVxuXG5leHBvcnQgY2xhc3MgTnNUZW1wbGF0ZWRJdGVtPFQ+IGltcGxlbWVudHMgTmdWaWV3VGVtcGxhdGU8eyBpbmRleDogbnVtYmVyOyBkYXRhOiBUIH0+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSB0ZW1wbGF0ZTogVGVtcGxhdGVSZWY8SXRlbUNvbnRleHQ8VD4+LCBwdWJsaWMgbG9jYXRpb246IFZpZXdDb250YWluZXJSZWYsIHByaXZhdGUgb25DcmVhdGU/OiAodmlldzogVmlldykgPT4gdm9pZCkge31cbiAgY3JlYXRlKGNvbnRleHQ/OiB7IGluZGV4OiBudW1iZXI7IGRhdGE6IFQgfSk6IFZpZXcge1xuICAgIGNvbnN0IHZpZXdSZWYgPSB0aGlzLmxvY2F0aW9uLmNyZWF0ZUVtYmVkZGVkVmlldyh0aGlzLnRlbXBsYXRlLCBjb250ZXh0ID8gdGhpcy5zZXR1cEl0ZW1Db250ZXh0KGNvbnRleHQpIDogbmV3IEl0ZW1Db250ZXh0KCkpO1xuICAgIHZpZXdSZWYuZGV0YWNoKCk7IC8vIGNyZWF0ZSBkZXRhY2hlZCwganVzdCBiZXdhcmUgdGhpcyBkb2Vzbid0IGFsd2F5cyB3b3JrIGFuZCB0aGUgdmlldyBtaWdodCBydW4gdGhlIGZpcnN0IENEIGFueXdheS5cbiAgICBjb25zdCByZXN1bHRWaWV3ID0gZ2V0SXRlbVZpZXdSb290KHZpZXdSZWYpO1xuICAgIHJlc3VsdFZpZXdbTkdfVklFV10gPSB2aWV3UmVmO1xuICAgIGlmICh0aGlzLm9uQ3JlYXRlKSB7XG4gICAgICB0aGlzLm9uQ3JlYXRlKHJlc3VsdFZpZXcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0VmlldztcbiAgfVxuICB1cGRhdGUodmlldzogVmlldywgY29udGV4dD86IHsgaW5kZXg6IG51bWJlcjsgZGF0YTogVCB9KTogdm9pZCB7XG4gICAgY29uc3Qgdmlld1JlZiA9IHRoaXMuZ2V0RW1iZWRkZWRWaWV3UmVmKHZpZXcpO1xuICAgIHRoaXMuc2V0dXBJdGVtQ29udGV4dChjb250ZXh0LCB2aWV3UmVmKTtcbiAgICB2aWV3UmVmPy5kZXRlY3RDaGFuZ2VzKCk7XG4gIH1cbiAgYXR0YWNoKHZpZXc6IFZpZXcpOiB2b2lkIHtcbiAgICBjb25zdCB2aWV3UmVmID0gdGhpcy5nZXRFbWJlZGRlZFZpZXdSZWYodmlldyk7XG4gICAgdmlld1JlZj8ucmVhdHRhY2goKTtcbiAgICB2aWV3UmVmPy5kZXRlY3RDaGFuZ2VzKCk7XG4gIH1cbiAgZGV0YWNoKHZpZXc6IFZpZXcpOiB2b2lkIHtcbiAgICBjb25zdCB2aWV3UmVmID0gdGhpcy5nZXRFbWJlZGRlZFZpZXdSZWYodmlldyk7XG4gICAgdmlld1JlZj8uZGV0YWNoKCk7XG4gIH1cbiAgZGlzcG9zZSh2aWV3OiBWaWV3KTogdm9pZCB7XG4gICAgY29uc3Qgdmlld1JlZiA9IHRoaXMuZ2V0RW1iZWRkZWRWaWV3UmVmKHZpZXcpO1xuICAgIHZpZXdSZWY/LmRlc3Ryb3koKTtcbiAgfVxuXG4gIGdldEVtYmVkZGVkVmlld1JlZih2aWV3OiBWaWV3KTogRW1iZWRkZWRWaWV3UmVmPEl0ZW1Db250ZXh0PFQ+PiB8IHVuZGVmaW5lZCB7XG4gICAgbGV0IHZpZXdSZWYgPSB2aWV3W05HX1ZJRVddO1xuXG4gICAgLy8gR2V0dGluZyBhbmd1bGFyIHZpZXcgZnJvbSBvcmlnaW5hbCBlbGVtZW50IChpbiBjYXNlcyB3aGVuIFByb3h5Vmlld0NvbnRhaW5lclxuICAgIC8vIGlzIHVzZWQgTmF0aXZlU2NyaXB0IGludGVybmFsbHkgd3JhcHMgaXQgaW4gYSBTdGFja0xheW91dClcbiAgICBpZiAoIXZpZXdSZWYgJiYgdmlldyBpbnN0YW5jZW9mIExheW91dEJhc2UgJiYgdmlldy5nZXRDaGlsZHJlbkNvdW50KCkgPiAwKSB7XG4gICAgICB2aWV3UmVmID0gdmlldy5nZXRDaGlsZEF0KDApW05HX1ZJRVddO1xuICAgIH1cbiAgICByZXR1cm4gdmlld1JlZjtcbiAgfVxuXG4gIGlzVmFsaWQodmlldzogVmlldykge1xuICAgIHJldHVybiAhIXRoaXMuZ2V0RW1iZWRkZWRWaWV3UmVmKHZpZXcpO1xuICB9XG5cbiAgcHJpdmF0ZSBzZXR1cEl0ZW1Db250ZXh0KHsgaW5kZXgsIGRhdGEgfTogeyBpbmRleDogbnVtYmVyOyBkYXRhOiBUIH0sIG9sZFZpZXc/OiBFbWJlZGRlZFZpZXdSZWY8SXRlbUNvbnRleHQ8VD4+KTogSXRlbUNvbnRleHQ8VD4ge1xuICAgIGNvbnN0IGNvbnRleHQ6IEl0ZW1Db250ZXh0PFQ+ID0gb2xkVmlldyA/IG9sZFZpZXcuY29udGV4dCA6IG5ldyBJdGVtQ29udGV4dDxUPigpO1xuICAgIGNvbnRleHQuJGltcGxpY2l0ID0gZGF0YTtcbiAgICBjb250ZXh0Lml0ZW0gPSBkYXRhO1xuICAgIGNvbnRleHQuaW5kZXggPSBpbmRleDtcbiAgICBjb250ZXh0LmV2ZW4gPSBpbmRleCAlIDIgPT09IDA7XG4gICAgY29udGV4dC5vZGQgPSAhY29udGV4dC5ldmVuO1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2V0dXBJdGVtVmlld0FyZ3M8VD4ge1xuICB2aWV3OiBFbWJlZGRlZFZpZXdSZWY8SXRlbUNvbnRleHQ8VD4+O1xuICBuYXRpdmVFbGVtZW50OiBWaWV3O1xuICBkYXRhOiBUO1xuICBpbmRleDogbnVtYmVyO1xuICBjb250ZXh0OiBJdGVtQ29udGV4dDxUPjtcbn1cblxuQENvbXBvbmVudCh7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAYW5ndWxhci1lc2xpbnQvY29tcG9uZW50LXNlbGVjdG9yXG4gIHNlbGVjdG9yOiAnTGlzdFZpZXcnLFxuICB0ZW1wbGF0ZTogYDxEZXRhY2hlZENvbnRhaW5lcj5cbiAgICA8bmctY29udGFpbmVyICNsb2FkZXI+PC9uZy1jb250YWluZXI+XG4gIDwvRGV0YWNoZWRDb250YWluZXI+YCxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIHByb3ZpZGVyczogW3sgcHJvdmlkZTogVEVNUExBVEVEX0lURU1TX0NPTVBPTkVOVCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTGlzdFZpZXdDb21wb25lbnQpIH1dLFxufSlcbmV4cG9ydCBjbGFzcyBMaXN0Vmlld0NvbXBvbmVudDxUID0gYW55PiBpbXBsZW1lbnRzIERvQ2hlY2ssIE9uRGVzdHJveSwgQWZ0ZXJDb250ZW50SW5pdCwgVGVtcGxhdGVkSXRlbXNIb3N0IHtcbiAgcHVibGljIGdldCBuYXRpdmVFbGVtZW50KCk6IExpc3RWaWV3IHtcbiAgICByZXR1cm4gdGhpcy50ZW1wbGF0ZWRJdGVtc1ZpZXc7XG4gIH1cblxuICBwcml2YXRlIHJlYWRvbmx5IF9pdGVyYWJsZURpZmZlcnM6IEl0ZXJhYmxlRGlmZmVycyA9IGluamVjdChJdGVyYWJsZURpZmZlcnMpO1xuICBwcml2YXRlIHJlYWRvbmx5IF9jaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYgPSBpbmplY3QoQ2hhbmdlRGV0ZWN0b3JSZWYpO1xuICBwcml2YXRlIHJlYWRvbmx5IF9lbGVtZW50UmVmOiBFbGVtZW50UmVmID0gaW5qZWN0KEVsZW1lbnRSZWYpO1xuXG4gIC8vIEkgYmVsaWV2ZSB0aGlzIG9ubHkgZXhpc3RzIHNvIHRoaXMgY2FuIGJlIGluaGVyaXRlZCBhbmQgcGVvcGxlIGNhbiBvdmVycmlkZSBpdC5cbiAgcHJvdGVjdGVkIHRlbXBsYXRlZEl0ZW1zVmlldzogTGlzdFZpZXcgPSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gIHByb3RlY3RlZCBfaXRlbXM6IFRbXSB8IE9ic2VydmFibGVBcnJheTxUPjtcbiAgcHJvdGVjdGVkIF9kaWZmZXI6IEl0ZXJhYmxlRGlmZmVyPFQ+O1xuICBwcm90ZWN0ZWQgX3RlbXBsYXRlTWFwOiBNYXA8c3RyaW5nLCBOc1RlbXBsYXRlZEl0ZW08VD4+O1xuICBwcm90ZWN0ZWQgX3ZpZXdUb1RlbXBsYXRlOiBXZWFrTWFwPFZpZXcsIHN0cmluZz4gPSBuZXcgV2Vha01hcDxWaWV3LCBzdHJpbmc+KCk7XG5cbiAgQFZpZXdDaGlsZCgnbG9hZGVyJywgeyByZWFkOiBWaWV3Q29udGFpbmVyUmVmLCBzdGF0aWM6IHRydWUgfSkgbG9hZGVyOiBWaWV3Q29udGFpbmVyUmVmO1xuXG4gIEBPdXRwdXQoKSBwdWJsaWMgc2V0dXBJdGVtVmlldyA9IG5ldyBFdmVudEVtaXR0ZXI8U2V0dXBJdGVtVmlld0FyZ3M8VD4+KCk7XG5cbiAgQENvbnRlbnRDaGlsZChUZW1wbGF0ZVJlZiwgeyByZWFkOiBUZW1wbGF0ZVJlZiwgc3RhdGljOiBmYWxzZSB9KSBpdGVtVGVtcGxhdGVRdWVyeTogVGVtcGxhdGVSZWY8SXRlbUNvbnRleHQ8VD4+O1xuXG4gIGZhbGxiYWNrSXRlbVRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxJdGVtQ29udGV4dDxUPj47XG5cbiAgQElucHV0KClcbiAgZ2V0IGl0ZW1zKCkge1xuICAgIHJldHVybiB0aGlzLl9pdGVtcztcbiAgfVxuXG4gIHNldCBpdGVtcyh2YWx1ZTogVFtdIHwgT2JzZXJ2YWJsZUFycmF5PFQ+KSB7XG4gICAgdGhpcy5faXRlbXMgPSB2YWx1ZTtcbiAgICBsZXQgbmVlZERpZmZlciA9IHRydWU7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgT2JzZXJ2YWJsZUFycmF5KSB7XG4gICAgICBuZWVkRGlmZmVyID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChuZWVkRGlmZmVyICYmICF0aGlzLl9kaWZmZXIgJiYgaXNMaXN0TGlrZUl0ZXJhYmxlKHZhbHVlKSkge1xuICAgICAgdGhpcy5fZGlmZmVyID0gdGhpcy5faXRlcmFibGVEaWZmZXJzLmZpbmQodGhpcy5faXRlbXMpLmNyZWF0ZSgoX2luZGV4LCBpdGVtKSA9PiB7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy50ZW1wbGF0ZWRJdGVtc1ZpZXcuaXRlbXMgPSB0aGlzLl9pdGVtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgY29uc3RydWN0b3IoX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYpO1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGNvbnN0cnVjdG9yKF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLCBfaXRlcmFibGVEaWZmZXJzOiBJdGVyYWJsZURpZmZlcnMsIF9jaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYpO1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGNvbnN0cnVjdG9yKF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLCBfaXRlcmFibGVEaWZmZXJzOiBJdGVyYWJsZURpZmZlcnMsIF9uZ1pvbmU6IE5nWm9uZSk7XG4gIGNvbnN0cnVjdG9yKCk7XG4gIC8vIHRoaXMgZWxlbWVudFJlZiBpcyBvbmx5IGhlcmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHJlYXNvbnNcbiAgY29uc3RydWN0b3IoX2VsZW1lbnRSZWY/OiBFbGVtZW50UmVmKSB7XG4gICAgaWYgKF9lbGVtZW50UmVmKSB7XG4gICAgICB0aGlzLnRlbXBsYXRlZEl0ZW1zVmlldyA9IF9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuICB9XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIGlmIChOYXRpdmVTY3JpcHREZWJ1Zy5pc0xvZ0VuYWJsZWQoKSkge1xuICAgICAgTmF0aXZlU2NyaXB0RGVidWcubGlzdFZpZXdMb2coJ1RlbXBsYXRlZEl0ZW1zVmlldy5uZ0FmdGVyQ29udGVudEluaXQoKScpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0SXRlbVRlbXBsYXRlcygpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy50ZW1wbGF0ZWRJdGVtc1ZpZXcgPSBudWxsO1xuXG4gICAgaWYgKHRoaXMuX3RlbXBsYXRlTWFwKSB7XG4gICAgICB0aGlzLl90ZW1wbGF0ZU1hcC5jbGVhcigpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2V0SXRlbVRlbXBsYXRlcygpIHtcbiAgICAvLyBUaGUgaXRlbVRlbXBsYXRlUXVlcnkgbWF5IGJlIGNoYW5nZWQgYWZ0ZXIgbGlzdCBpdGVtcyBhcmUgYWRkZWQgdGhhdCBjb250YWluIDx0ZW1wbGF0ZT4gaW5zaWRlLFxuICAgIC8vIHNvIGNhY2hlIGFuZCB1c2Ugb25seSB0aGUgb3JpZ2luYWwgdGVtcGxhdGUgdG8gYXZvaWQgZXJyb3JzLlxuICAgIHRoaXMuZmFsbGJhY2tJdGVtVGVtcGxhdGUgPSB0aGlzLml0ZW1UZW1wbGF0ZVF1ZXJ5O1xuICAgIGlmICh0aGlzLmZhbGxiYWNrSXRlbVRlbXBsYXRlICYmICF0aGlzLl90ZW1wbGF0ZU1hcD8uaGFzKCdkZWZhdWx0JykpIHtcbiAgICAgIC8vIGFwcGFyZW50bHkgeW91IGNhbiBjcmVhdGUgYSBDb3JlIExpc3RWaWV3IHdpdGhvdXQgYSB0ZW1wbGF0ZS4uLlxuICAgICAgLy8gd2UgYWxzbyBhZGQgYSBmYWxsYmFjayBkZWZhdWx0IGZvciB3aGVuIHRoZSB1c2VyIHNldHMgbXVsdGlwbGUgdGVtcGxhdGVzIGJ1dCBubyB0ZW1wbGF0ZVNlbGVjdG9yXG4gICAgICB0aGlzLnJlZ2lzdGVyVGVtcGxhdGUoJ2RlZmF1bHQnLCB0aGlzLmZhbGxiYWNrSXRlbVRlbXBsYXRlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fdGVtcGxhdGVNYXApIHtcbiAgICAgIC8vIHNvbWV0aW1lcyB0ZW1wbGF0ZXMgYXJlIHJlZ2lzdGVyZWQgYmVmb3JlIGxvYWRlciBpcyByZWFkeSwgc28gd2UgdXBkYXRlIGhlcmVcbiAgICAgIHRoaXMuX3RlbXBsYXRlTWFwLmZvckVhY2goKHQpID0+ICh0LmxvY2F0aW9uID0gdGhpcy5sb2FkZXIpKTtcbiAgICAgIGlmIChOYXRpdmVTY3JpcHREZWJ1Zy5pc0xvZ0VuYWJsZWQoKSkge1xuICAgICAgICBOYXRpdmVTY3JpcHREZWJ1Zy5saXN0Vmlld0xvZygnU2V0dGluZyB0ZW1wbGF0ZXMnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGVtcGxhdGVzOiBLZXllZFRlbXBsYXRlW10gPSBbXTtcbiAgICAgIHRoaXMuX3RlbXBsYXRlTWFwLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgdGVtcGxhdGVzLnB1c2goe1xuICAgICAgICAgIGNyZWF0ZVZpZXc6ICgpID0+IG51bGwsIC8vIHdlJ2xsIGhhbmRsZSBjcmVhdGlvbiBsYXRlciwgb3RoZXJ3aXNlIGNvcmUgd2lsbCBjcmVhdGUgYW4gaW52YWxpZCB0ZW1wbGF0ZVxuICAgICAgICAgIGtleSxcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMudGVtcGxhdGVkSXRlbXNWaWV3Lml0ZW1UZW1wbGF0ZXMgPSB0ZW1wbGF0ZXM7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlZ2lzdGVyVGVtcGxhdGUoa2V5OiBzdHJpbmcsIHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxJdGVtQ29udGV4dDxUPj4pIHtcbiAgICBpZiAoTmF0aXZlU2NyaXB0RGVidWcuaXNMb2dFbmFibGVkKCkpIHtcbiAgICAgIE5hdGl2ZVNjcmlwdERlYnVnLmxpc3RWaWV3TG9nKGByZWdpc3RlclRlbXBsYXRlIGZvciBrZXk6ICR7a2V5fSwgJHt0aGlzLmxvYWRlcn1gKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3RlbXBsYXRlTWFwKSB7XG4gICAgICB0aGlzLl90ZW1wbGF0ZU1hcCA9IG5ldyBNYXA8c3RyaW5nLCBOc1RlbXBsYXRlZEl0ZW08VD4+KCk7XG4gICAgfVxuXG4gICAgdGhpcy5fdGVtcGxhdGVNYXAuc2V0KGtleSwgbmV3IE5zVGVtcGxhdGVkSXRlbTxUPih0ZW1wbGF0ZSwgdGhpcy5sb2FkZXIsICh2KSA9PiB0aGlzLl92aWV3VG9UZW1wbGF0ZS5zZXQodiwga2V5KSkpO1xuICB9XG5cbiAgQEhvc3RMaXN0ZW5lcignaXRlbUxvYWRpbmcnLCBbJyRldmVudCddKVxuICBAcHJvZmlsZVxuICBwdWJsaWMgb25JdGVtTG9hZGluZyhhcmdzOiBJdGVtRXZlbnREYXRhKSB7XG4gICAgaWYgKCF0aGlzLl90ZW1wbGF0ZU1hcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGluZGV4ID0gYXJncy5pbmRleDtcbiAgICBjb25zdCBsdmlldzogTGlzdFZpZXcgPSA8TGlzdFZpZXc+YXJncy5vYmplY3Q7XG4gICAgY29uc3QgaXRlbXMgPSBsdmlldy5pdGVtcztcbiAgICBjb25zdCBjdXJyZW50SXRlbSA9ICdnZXRJdGVtJyBpbiBpdGVtcyAmJiB0eXBlb2YgaXRlbXMuZ2V0SXRlbSA9PT0gJ2Z1bmN0aW9uJyA/IGl0ZW1zLmdldEl0ZW0oaW5kZXgpIDogaXRlbXNbaW5kZXhdO1xuXG4gICAgbGV0IHRlbXBsYXRlOiBOc1RlbXBsYXRlZEl0ZW08VD47XG5cbiAgICBpZiAoYXJncy52aWV3KSB7XG4gICAgICBpZiAoTmF0aXZlU2NyaXB0RGVidWcuaXNMb2dFbmFibGVkKCkpIHtcbiAgICAgICAgTmF0aXZlU2NyaXB0RGVidWcubGlzdFZpZXdMb2coYG9uSXRlbUxvYWRpbmc6ICR7aW5kZXh9IC0gUmV1c2luZyBleGlzdGluZyB2aWV3YCk7XG4gICAgICB9XG5cbiAgICAgIGxldCB0ZW1wbGF0ZUtleSA9IHRoaXMuX3ZpZXdUb1RlbXBsYXRlLmdldChhcmdzLnZpZXcpO1xuICAgICAgaWYgKCF0ZW1wbGF0ZUtleSAmJiBhcmdzLnZpZXcgaW5zdGFuY2VvZiBMYXlvdXRCYXNlICYmIGFyZ3Mudmlldy5nZXRDaGlsZHJlbkNvdW50KCkgPiAwKSB7XG4gICAgICAgIHRlbXBsYXRlS2V5ID0gdGhpcy5fdmlld1RvVGVtcGxhdGUuZ2V0KGFyZ3Mudmlldy5nZXRDaGlsZEF0KDApKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGVtcGxhdGVLZXkpIHtcbiAgICAgICAgLy8gdGhpcyB0ZW1wbGF0ZSB3YXMgbm90IGNyZWF0ZWQgYnkgdXNcbiAgICAgICAgaWYgKE5hdGl2ZVNjcmlwdERlYnVnLmlzTG9nRW5hYmxlZCgpKSB7XG4gICAgICAgICAgTmF0aXZlU2NyaXB0RGVidWcubGlzdFZpZXdFcnJvcihgVmlld1JlZmVyZW5jZSBub3QgZm91bmQgZm9yIGl0ZW0gJHtpbmRleH0uIFZpZXcgcmVjeWNsaW5nIGlzIG5vdCB3b3JraW5nYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGVtcGxhdGUgPSB0aGlzLl90ZW1wbGF0ZU1hcC5nZXQodGVtcGxhdGVLZXkpO1xuICAgICAgdGVtcGxhdGUudXBkYXRlKGFyZ3MudmlldywgeyBpbmRleCwgZGF0YTogY3VycmVudEl0ZW0gfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRoaXMgc2hvdWxkIG5ldmVyIGVudGVyIGlmIGl0IGNyZWF0ZXMgdGhlIHZpZXdcbiAgICAgIGNvbnN0IHRlbXBsYXRlS2V5ID0gdHlwZW9mIGx2aWV3Lml0ZW1UZW1wbGF0ZVNlbGVjdG9yID09PSAnZnVuY3Rpb24nID8gbHZpZXcuaXRlbVRlbXBsYXRlU2VsZWN0b3IoY3VycmVudEl0ZW0sIGluZGV4LCBpdGVtcykgOiAnZGVmYXVsdCc7XG4gICAgICB0ZW1wbGF0ZSA9IHRoaXMuX3RlbXBsYXRlTWFwLmdldCh0ZW1wbGF0ZUtleSk7XG4gICAgICBpZiAoIXRlbXBsYXRlKSB7XG4gICAgICAgIGlmIChOYXRpdmVTY3JpcHREZWJ1Zy5pc0xvZ0VuYWJsZWQoKSkge1xuICAgICAgICAgIE5hdGl2ZVNjcmlwdERlYnVnLmxpc3RWaWV3RXJyb3IoYFRlbXBsYXRlIGZvciBrZXkgJyR7dGVtcGxhdGVLZXl9JyBub3QgZm91bmQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYXJncy52aWV3ID0gdGVtcGxhdGUuY3JlYXRlKHsgaW5kZXgsIGRhdGE6IGN1cnJlbnRJdGVtIH0pO1xuICAgIH1cbiAgICB0aGlzLnNldHVwVmlld1JlZih0ZW1wbGF0ZS5nZXRFbWJlZGRlZFZpZXdSZWYoYXJncy52aWV3KSwgY3VycmVudEl0ZW0sIGluZGV4LCBhcmdzLnZpZXcpO1xuXG4gICAgdGVtcGxhdGUuYXR0YWNoKGFyZ3Mudmlldyk7XG4gICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICB9XG5cbiAgcHVibGljIHNldHVwVmlld1JlZih2aWV3UmVmOiBFbWJlZGRlZFZpZXdSZWY8SXRlbUNvbnRleHQ8VD4+LCBkYXRhOiBULCBpbmRleDogbnVtYmVyLCBuYXRpdmVFbGVtZW50OiBWaWV3KTogdm9pZCB7XG4gICAgY29uc3QgY29udGV4dCA9IHZpZXdSZWYuY29udGV4dDtcbiAgICB0aGlzLnNldHVwSXRlbVZpZXcubmV4dCh7IHZpZXc6IHZpZXdSZWYsIG5hdGl2ZUVsZW1lbnQsIGRhdGE6IGRhdGEsIGluZGV4OiBpbmRleCwgY29udGV4dDogY29udGV4dCB9KTtcbiAgfVxuXG4gIG5nRG9DaGVjaygpIHtcbiAgICBpZiAodGhpcy5fZGlmZmVyKSB7XG4gICAgICBpZiAoTmF0aXZlU2NyaXB0RGVidWcuaXNMb2dFbmFibGVkKCkpIHtcbiAgICAgICAgTmF0aXZlU2NyaXB0RGVidWcubGlzdFZpZXdMb2coJ25nRG9DaGVjaygpIC0gZXhlY3V0ZSBkaWZmZXInKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2hhbmdlcyA9IHRoaXMuX2RpZmZlci5kaWZmKHRoaXMuX2l0ZW1zIGFzIFRbXSk7XG4gICAgICBpZiAoY2hhbmdlcykge1xuICAgICAgICBpZiAoTmF0aXZlU2NyaXB0RGVidWcuaXNMb2dFbmFibGVkKCkpIHtcbiAgICAgICAgICBOYXRpdmVTY3JpcHREZWJ1Zy5saXN0Vmlld0xvZygnbmdEb0NoZWNrKCkgLSByZWZyZXNoJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRlbXBsYXRlZEl0ZW1zVmlldy5yZWZyZXNoKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB0eXBlIFJvb3RMb2NhdG9yID0gKG5vZGVzOiBBcnJheTx1bmtub3duPiwgbmVzdExldmVsOiBudW1iZXIpID0+IFZpZXc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJdGVtVmlld1Jvb3Qodmlld1JlZjogRW1iZWRkZWRWaWV3UmVmPHVua25vd24+LCByb290TG9jYXRvcjogUm9vdExvY2F0b3IgPSBleHRyYWN0U2luZ2xlVmlld1JlY3Vyc2l2ZSk6IFZpZXcge1xuICBjb25zdCByb290VmlldyA9IHJvb3RMb2NhdG9yKHZpZXdSZWYucm9vdE5vZGVzLCAwKTtcbiAgcmV0dXJuIHJvb3RWaWV3O1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQGFuZ3VsYXItZXNsaW50L2RpcmVjdGl2ZS1zZWxlY3RvclxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW25zVGVtcGxhdGVLZXldLFtuc1RlbXBsYXRlS2V5c10nIH0pXG5leHBvcnQgY2xhc3MgVGVtcGxhdGVLZXlEaXJlY3RpdmU8VD4ge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxUPiwgQEhvc3QoKSBASW5qZWN0KFRFTVBMQVRFRF9JVEVNU19DT01QT05FTlQpIHByaXZhdGUgY29tcDogVGVtcGxhdGVkSXRlbXNIb3N0PFQ+KSB7fVxuXG4gIEBJbnB1dCgpXG4gIHNldCBuc1RlbXBsYXRlS2V5KHZhbHVlOiBzdHJpbmcpIHtcbiAgICBpZiAodGhpcy5jb21wICYmIHRoaXMudGVtcGxhdGVSZWYpIHtcbiAgICAgIHRoaXMuY29tcC5yZWdpc3RlclRlbXBsYXRlKHZhbHVlLCB0aGlzLnRlbXBsYXRlUmVmKTtcbiAgICB9XG4gIH1cbiAgQElucHV0KClcbiAgc2V0IG5zVGVtcGxhdGVLZXlzKHZhbHVlczogc3RyaW5nW10pIHtcbiAgICAvLyBzaW5nbGUgdGVtcGxhdGUgd2l0aCBtdWx0aXBsZSBrZXlzXG4gICAgaWYgKHRoaXMuY29tcCAmJiB0aGlzLnRlbXBsYXRlUmVmICYmIHZhbHVlcykge1xuICAgICAgdmFsdWVzLmZvckVhY2goKHZhbHVlKSA9PiB0aGlzLmNvbXAucmVnaXN0ZXJUZW1wbGF0ZSh2YWx1ZSwgdGhpcy50ZW1wbGF0ZVJlZikpO1xuICAgIH1cbiAgfVxufVxuIl19